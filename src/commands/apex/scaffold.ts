import { DescribeSObjectResult, Field } from '@jsforce/jsforce-node';
import { Flags } from '@salesforce/sf-plugins-core';
import { CommandBase } from '../../helpers/command-base.js';
import { SfTasks as SfTasks } from '../../helpers/sf-tasks.js';
import Utils from '../../helpers/utils.js';
import { OptionsFactory } from '../../helpers/options-factory.js';
import { ScaffoldOptions } from '../../helpers/scaffold-options.js';
import SfProject from '../../helpers/sf-project.js';
import { SfCore } from '../../helpers/sf-core.js';

export default class Scaffold extends CommandBase {
  public static description = CommandBase.messages.getMessage('apex.scaffold.commandDescription');

  public static examples = [
    `$ sf apex scaffold -u myOrgAlias -s Account,MyObject__c'
    Generates AccountTest.cls & MyObjectTest.cls Apex test classes (and cls-meta files) for the Account & MyObject__c SObject types. Random values assigned to required fields by default`,
    `$ sf apex scaffold -u myOrgAlias -o scaffold-options.json
    Generates Apex test classes (and cls-meta files) for specified CustomObjects. The specified options file is used.`,
  ];

  public static readonly flags = {
    sobjects: Flags.string({
      char: 's',
      description: CommandBase.messages.getMessage('apex.scaffold.sObjectsFlagDescription'),
      required: true
    }),
    options: Flags.file({
      char: 'o',
      description: CommandBase.messages.getMessage('apex.scaffold.optionsFlagDescription'),
    }),
    ...CommandBase.commonFlags,
    ...CommandBase.flags,
  };

  private static META_XML =
    '<?xml version="1.0" encoding="UTF-8"?>\n' +
    '<ApexClass xmlns="http://soap.sforce.com/2006/04/metadata">\n' +
    '<apiVersion>API_VERSION_TOKEN</apiVersion>\n' +
    '<status>Active</status>\n' +
    '</ApexClass>';

  private static MAX_CLASS_NAME_LENGTH = 40;
  private schemas = new Map<string, DescribeSObjectResult>();

  
  public static generateObjectApex(schema: DescribeSObjectResult, options: ScaffoldOptions): Map<string, string> {
    if(schema && options) {
      const codeLines = new Map<string, string>();
      for (const field of schema.fields) {
        // Skip optional fields?
        if (options.isExcluded(field)) {
          continue;
        }
        const value = SfCore.generateValue(field);
        const formattedValue = Scaffold.formatValue(field, value);
        codeLines.set(field.name, `${field.name} = ${formattedValue}`);
      }
      return codeLines;
    }
  }

  private static formatValue(field: Field, value: any): any {
    switch (field.type) {

      // Wrap value in quotations
      case 'anytype':
      case 'string':
      case 'encryptedstring':
      case 'base64':
      case 'textarea':
      case 'address':
      case 'email':
      case 'phone':
      case 'url':       
      case 'dataCategoryGroupReference': 
      case 'id':
      case 'reference':
      case 'location':
      case 'combobox':
      case 'multipicklist':
      case 'picklist':
      case 'textarea1': 
        return `'${value}'`;

      // Return string
      case 'int':
      case 'integer':
      case 'double':
      case 'percent':
      case 'currency':
      case 'boolean':
        return `${value}`;
      case 'long':
        return `${value}L`;

      // Ignore value
      case 'date':
        return 'Date.today()';
      case 'datetime':
        return 'Datetime.now()';
      case 'time':
        return 'Datetime.getTime()';
      
      default:
        return value;
    }
  }

  public generateTestSetupCode(simpleName: string, schema: DescribeSObjectResult, options: ScaffoldOptions): any {
    if(simpleName && schema && options) {
      // Don't exceed max class name length
      const noUnderscoreName = simpleName.replace(/_/g, '');
      const className = `${noUnderscoreName.substring(0, Scaffold.MAX_CLASS_NAME_LENGTH - 4)}Test`;
      const varName = `${className.substring(0, 1).toLowerCase()}${className.substring(1)}`;
      const pre = '\t\t\t';
      const classLines = [
        '// This class was generated by the acu-pack:apex:scaffold command.',
        '@IsTest',
        `public with sharing class ${className} {`,
        '',
        '\t@TestSetup',
        '\tstatic void setupTestData() {',
        '\t\t// Create instance',
        `\t\t${schema.name} ${varName} = new ${schema.name}( `,
      ];

      const codeLines = Scaffold.generateObjectApex(schema, options); 
      const sortedKeys = Utils.sortArray(Array.from(codeLines.keys()));
      for (const key of sortedKeys) {
        let classLine = codeLines.get(key as string);
        if (key !== sortedKeys[sortedKeys.length - 1]) {
          classLine += ',';
        }
        classLines.push(pre+classLine);
      }

      classLines.push(...['\t\t);', `\t\tinsert ${varName};`, '\t}', '}']);
      return {
        name: className,
        contents: classLines.join('\n'),
      };
    }
  }

  protected async runInternal(): Promise<void> {
    const { flags } = await this.parse(Scaffold);
    let options: ScaffoldOptions;
    // Read/Write the options file if it does not exist already
    if (flags.options) {
      const optionsFilePath: string = flags.options;
      options = await OptionsFactory.get(ScaffoldOptions, optionsFilePath);
      if (!options) {
        this.raiseError(`Unable to read options file: ${optionsFilePath}.`);
      }
    } else {
      options = new ScaffoldOptions();
      await options.loadDefaults();
    }

    const objects: string[] = [];
    if (flags.sobjects) {
      const objList: string = flags.sobjects;
      objects.push(...objList.split(','));
    }

    this.UX.log('Retrieving Schemas...');
    for (const sObjectType of objects) {
      await this.getSchema(sObjectType.replace(' ', ''));
    }

    this.UX.log('Reading ./sf-project.json file...');
    const project = await SfProject.default();
    const defaultFolder: string = project.getDefaultDirectory();

    this.UX.log('Generating Apex cls & cls-meta files...');

    const rootPath = `./${defaultFolder}/main/default/classes/`;
    await Utils.mkDirPath(rootPath);

    for (const [schemaName, schema] of this.schemas) {
      this.UX.log('\t' + schemaName);
      const fileDetails = this.generateTestSetupCode(schemaName, schema, options);

      await Utils.writeFile(rootPath + `${fileDetails.name as string}.cls`, fileDetails.contents);

      await Utils.writeFile(
        rootPath + `${fileDetails.name as string}.cls-meta.xml`,
        Scaffold.META_XML.replace(/API_VERSION_TOKEN/, project.sourceApiVersion)
      );
    }
  }
  
  private async getSchema(sObjectType: string): Promise<DescribeSObjectResult> {
    let schema = this.schemas.get(sObjectType);
    if (!schema) {
      schema = await SfTasks.describeObject(this.org, sObjectType);
      if (!schema) {
        this.raiseError('The returned schema is null.');
      }
      if (!schema.fields) {
        this.raiseError('The returned schema does not contain a fields member.');
      }
      this.schemas.set(schema.name.split('__')[0], schema);
    }
    return schema;
  }
}
