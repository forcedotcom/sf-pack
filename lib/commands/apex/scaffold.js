import { Flags } from '@salesforce/sf-plugins-core';
import { CommandBase } from '../../helpers/command-base.js';
import { SfTasks as SfTasks } from '../../helpers/sf-tasks.js';
import Utils from '../../helpers/utils.js';
import { OptionsFactory } from '../../helpers/options-factory.js';
import { ScaffoldOptions } from '../../helpers/scaffold-options.js';
import SfProject from '../../helpers/sf-project.js';
import { SfCore } from '../../helpers/sf-core.js';
export default class Scaffold extends CommandBase {
    static description = CommandBase.messages.getMessage('apex.scaffold.commandDescription');
    static examples = [
        `$ sf apex scaffold -u myOrgAlias -s Account,MyObject__c'
    Generates AccountTest.cls & MyObjectTest.cls Apex test classes (and cls-meta files) for the Account & MyObject__c SObject types. Random values assigned to required fields by default`,
        `$ sf apex scaffold -u myOrgAlias -o scaffold-options.json
    Generates Apex test classes (and cls-meta files) for specified CustomObjects. The specified options file is used.`,
    ];
    static flags = {
        sobjects: Flags.string({
            char: 's',
            description: CommandBase.messages.getMessage('apex.scaffold.sObjectsFlagDescription'),
            required: true
        }),
        options: Flags.file({
            char: 'o',
            description: CommandBase.messages.getMessage('apex.scaffold.optionsFlagDescription'),
        }),
        ...CommandBase.commonFlags,
        ...CommandBase.flags,
    };
    static META_XML = '<?xml version="1.0" encoding="UTF-8"?>\n' +
        '<ApexClass xmlns="http://soap.sforce.com/2006/04/metadata">\n' +
        '<apiVersion>API_VERSION_TOKEN</apiVersion>\n' +
        '<status>Active</status>\n' +
        '</ApexClass>';
    static MAX_CLASS_NAME_LENGTH = 40;
    schemas = new Map();
    static generateObjectApex(schema, options) {
        if (schema && options) {
            const codeLines = new Map();
            for (const field of schema.fields) {
                // Skip optional fields?
                if (options.isExcluded(field)) {
                    continue;
                }
                const value = SfCore.generateValue(field);
                const formattedValue = Scaffold.formatValue(field, value);
                codeLines.set(field.name, `${field.name} = ${formattedValue}`);
            }
            return codeLines;
        }
    }
    static formatValue(field, value) {
        switch (field.type) {
            // Wrap value in quotations
            case 'anytype':
            case 'string':
            case 'encryptedstring':
            case 'base64':
            case 'textarea':
            case 'address':
            case 'email':
            case 'phone':
            case 'url':
            case 'dataCategoryGroupReference':
            case 'id':
            case 'reference':
            case 'location':
            case 'combobox':
            case 'multipicklist':
            case 'picklist':
            case 'textarea1':
                return `'${value}'`;
            // Return string
            case 'int':
            case 'integer':
            case 'double':
            case 'percent':
            case 'currency':
            case 'boolean':
                return `${value}`;
            case 'long':
                return `${value}L`;
            // Ignore value
            case 'date':
                return 'Date.today()';
            case 'datetime':
                return 'Datetime.now()';
            case 'time':
                return 'Datetime.getTime()';
            default:
                return value;
        }
    }
    generateTestSetupCode(simpleName, schema, options) {
        if (simpleName && schema && options) {
            // Don't exceed max class name length
            const noUnderscoreName = simpleName.replace(/_/g, '');
            const className = `${noUnderscoreName.substring(0, Scaffold.MAX_CLASS_NAME_LENGTH - 4)}Test`;
            const varName = `${className.substring(0, 1).toLowerCase()}${className.substring(1)}`;
            const pre = '\t\t\t';
            const classLines = [
                '// This class was generated by the acu-pack:apex:scaffold command.',
                '@IsTest',
                `public with sharing class ${className} {`,
                '',
                '\t@TestSetup',
                '\tstatic void setupTestData() {',
                '\t\t// Create instance',
                `\t\t${schema.name} ${varName} = new ${schema.name}( `,
            ];
            const codeLines = Scaffold.generateObjectApex(schema, options);
            const sortedKeys = Utils.sortArray(Array.from(codeLines.keys()));
            for (const key of sortedKeys) {
                let classLine = codeLines.get(key);
                if (key !== sortedKeys[sortedKeys.length - 1]) {
                    classLine += ',';
                }
                classLines.push(pre + classLine);
            }
            classLines.push(...['\t\t);', `\t\tinsert ${varName};`, '\t}', '}']);
            return {
                name: className,
                contents: classLines.join('\n'),
            };
        }
    }
    async runInternal() {
        const { flags } = await this.parse(Scaffold);
        let options;
        // Read/Write the options file if it does not exist already
        if (flags.options) {
            const optionsFilePath = flags.options;
            options = await OptionsFactory.get(ScaffoldOptions, optionsFilePath);
            if (!options) {
                this.raiseError(`Unable to read options file: ${optionsFilePath}.`);
            }
        }
        else {
            options = new ScaffoldOptions();
            await options.loadDefaults();
        }
        const objects = [];
        if (flags.sobjects) {
            const objList = flags.sobjects;
            objects.push(...objList.split(','));
        }
        this.UX.log('Retrieving Schemas...');
        for (const sObjectType of objects) {
            await this.getSchema(sObjectType.replace(' ', ''));
        }
        this.UX.log('Reading ./sf-project.json file...');
        const project = await SfProject.default();
        const defaultFolder = project.getDefaultDirectory();
        this.UX.log('Generating Apex cls & cls-meta files...');
        const rootPath = `./${defaultFolder}/main/default/classes/`;
        await Utils.mkDirPath(rootPath);
        for (const [schemaName, schema] of this.schemas) {
            this.UX.log('\t' + schemaName);
            const fileDetails = this.generateTestSetupCode(schemaName, schema, options);
            await Utils.writeFile(rootPath + `${fileDetails.name}.cls`, fileDetails.contents);
            await Utils.writeFile(rootPath + `${fileDetails.name}.cls-meta.xml`, Scaffold.META_XML.replace(/API_VERSION_TOKEN/, project.sourceApiVersion));
        }
    }
    async getSchema(sObjectType) {
        let schema = this.schemas.get(sObjectType);
        if (!schema) {
            schema = await SfTasks.describeObject(this.org, sObjectType);
            if (!schema) {
                this.raiseError('The returned schema is null.');
            }
            if (!schema.fields) {
                this.raiseError('The returned schema does not contain a fields member.');
            }
            this.schemas.set(schema.name.split('__')[0], schema);
        }
        return schema;
    }
}
//# sourceMappingURL=scaffold.js.map